/* 
 * Notes to self about OpenDNSSEC SOA serial management.
 * 
 * NOTE: Any comparison of serials using < > or max() or arithmetic using '+'
 * would seem to ignore the possibility of wrap around which does not seem
 * right... See '!!!' annotations below.
 * 
 * namedb_struct:
 * ==============
 * OpenDNSSEC manages SOA serials using the namedb_struct, a so-called "domain
 * name database", which includes information about the zone, domains, denials
 * and the following SOA serial related fields (all of which are initialized by
 * namedb_create() and by signer cli cmd clear to zero):
 * 
 *   inbserial       - "inbound serial": set:
 *                     from backup field "inbound" when starting up.
 *                     from SOA RR RDATA SERIAL from incoming file or XFR.
 *   intserial       - "internal serial": set:
 *                     from backup field "internal" when starting up.
 *                     by namedb_update_serial() - see logic below. 
 *   outserial       - "outbound": set:
 *                     from backup field "outbound" when starting up.
 *                     from tools_output from signer/worker TASK_WRITE.
 *   altserial       - set to XXX provided via signer sign --serial XXX.
 *   serial_updated  - set to 1 by adapi_process_soa from adapi_process_rr
 *                     from adapi_add/del_rr from worker_perform_task in
 *                     signer/worker.c for TASK_READ, after calling
 *                     named_update_serial() and actually modifying the soa rr.
 *   force_serial    - set to 1 if signer sign --serial XXX was provided on the
 *                     cmd line and the serial was util_serial_gt() than
 *                     max(outserial, inb_ound_serial).        !!!
 *                     cleared by namedb_update_serial().
 *   have_serial     - used to indicate that this is not the first time this
 *                     zone has been seen and thus we have prior state.
 * 
 *                     set to 1 if signer sign clear fails.
 *                     set to 1 by tools_output() which does 'write zone to
 *                     output adapter'
 *                     set to 1 when loading backup data on startup.
 * 
 *                     If NOT set, namedb_update_serial() outputs log warnings
 *                     if the specified/calculated serial does not increase the
 *                     previous SOA serial. Does this field do anything else?
 *                     Why log warnings if this field is set?
 * 
 *                     Yes, in 'counter' mode if have_serial is set then an
 *                     arg_inbound_serial that does NOT increase the previous
 *                     SOA serial will be used anyway. When have_serial is not
 *                     set then in this case the fallback SOA SERIAL value
 *                     'prev' + 1 is used instead.
 * 
 *                     Also, if have_serial is set then in all modes except
 *                     'keep' the check against the previous SOA serial is done
 *                     either against outserial or arg_inbound_serial, but if
 *                     have_serial is NOT set the comparison is only against
 *                     arg_inbound_serial. So setting have_serial _may_ cause
 *                     a proposed serial number to be based on the 'outserial'
 *                     rather than the arg_inbound_serial...
 * 
 *                     And also: if have_serial is NOT set then intserial is
 *                     set by namedb_update_serial() to the newly chosen value,
 *                     but when set the newly chosen value is not used directly
 *                     but rather only after "updating" it. See below.
 * 
 *                     xfrd_recover() only reads .state files in have_serial is
 *                     set.
 * 
 * nameb_update_serial() arg "inbound_serial" client logic:
 * ========================================================
 * NOTE: arg_inbound_serial is used by namedb_update_serial() instead of
 * inbserial in the namedb_struct, though it does log inbserial... how does
 * the inbound_serial argument relate to the inbserial field in the structure?
 * Answer: It is SOA RR RDATA SERIAL during TASK_READ, and inbserial during
 * TASK_SIGN.
 * 
 * 1. adapi_process_soa(zone, rr) sets arg_inbound_serial to the SOA RR RDATA
 *    "SERIAL" field defined in RFC 1035 section 3.3.13 SOA RDATA format as:
 *      "The unsigned 32 bit version number of the original copy of the zone.
 *       Zone transfers preserve this value.  This value wraps and should be
 *       compared using sequence space arithmetic."
 *    LDNS is used to extract the uint32 value from the SOA RR RDATA SERIAL field:
 *    ldns_rdf2native_int32(ldns_rr_rdf(rr, SE_SOA_RDATA_SERIAL))
 * 
 *    So the SOA SERIAL from the incoming data (be it file or XFR) is used as
 *    the arg_inbound_serial (ultimately called from addns.c/adfile.c via the
 *    adapi_add_rr() and adapi_del_rr() functions), which looks like it is in
 *    turn invoked ultimately in worker_perform_task in signer/worker.c for
 *    TASK_READ.
 *
 * 2. zone_update_serial() sets arg_inbound_serial to the inbserial field
 *    value (why!?! given that it already passes in the db object which has
 *    the inbserial value inside it???). This is invoked by worker_perform_task
 *    in signer/worker.c for TASK_SIGN.
 * 
 * According to code in signer/worker.c worker_perform_task() it seems that the
 * order of tasks is: TASK_SIGNCONF -> TASK_READ -> TASK_SIGN -> TASK_WRITE -v
 *                                                      ^---------------------
 * With both TASK_READ and TASK_SIGN causing calls to namedb_update_serial().
 * 
 * named_update_serial() logic:
 * ============================
 * NOTE: Whether the altserial set by signer sign --serial is used depends on
 * the status later when namedb_update_serial() processes the namedb_struct:
 * 
 * Key:
 *   < >  denote integer less than and greater than
 *
 *   GT   denotes util_serial_gt() which in turn uses the
 *        DNS_SERIAL_GT macro defined as:
 *          ((int)(((a) - (b)) & 0xFFFFFFFF) > 0)
 *        The comment for this macro is interesting:
 *          "copycode: This define is taken from BIND9"
 * 
 * Logic:
 *   IF have_serial AND outserial > arg_inbound_serial:         !!!
 *     prev = outserial
 *   ELSE:
 *     prev = arg_inbound_serial
 *
 *   IF force_serial:
 *     IF alt_serial GT 'prev':
 *       soa = altserial
 *     ELSE:
 *       soa = 'prev' + 1                                         !!!
 *   ELIF format == 'unixtime':
 *     computed_soa = time_now()                                  [1]
 *     IF computed_soa GT 'prev':
 *       soa = computed_soa
 *     ELSE:
 *       soa = 'prev' + 1                                         !!!
 *       IF NOT have_serial: log warning
 *   ELIF format == 'datecounter':
 *     computed_soa = time_now(as %Y%m%d as uint32)               [1]
 *     IF computed_soa GT 'prev':
 *       soa = computed_soa
 *     ELSE:
 *       soa = 'prev' + 1                                         !!!
 *       IF NOT have_serial: log warning
 *   ELIF format == 'counter':
 *     computed_soa = arg_inbound_serial + 1                      !!!
 *     IF computed_soa GT 'prev':
 *       soa = computed_soa
 *     ELIF have_serial:                                          [2]
 *       soa = 'prev' + 1                                         !!!
 *   ELIF format == 'keep':
 *     computed_soa = arg_inbound_serial
 *     'prev' = outserial                                         [3]
 *     IF computed_soa GT outserial:                              [4]
 *       soa = computed_soa
 *   ELSE:
 *     error
 * 
 *   update = soa - 'prev'                                        [5]
 *   IF update > 0x7FFFFFFF:
 *     update = 0x7FFFFFFF
 *   IF have_serial:
 *     intserial = 'prev' + update
 *   ELSE:
 *     intserial = soa
 * 
 * Footnotes:
 *   [1] time_now() is either time(), or if BOTH the ENFORCER_TIMESHIFT define
 *       AND the ENFORCER_TIMESHIFT environment variable are set then
 *       time_now() is timeshift2time(env var value). Is this possible with the
 *       signer or only with the enforcer? Note that this feature is for
 *       debugging so not important for understanding the correct busines
 *       logic here.
 *   [2] Why only in 'counter' format is 'prev' + 1 not used if
 *       have_serial is not set?
 *   [3] In 'keep' mode 'prev' is forced to outserial, which only affects the
 *       final soa if have_serial is set and thus 'update' arithmetic is done
 *       (see [5]), i.e. undoing the forced use of inbound_serial as is usually
 *       used for 'prev' when have_serial is set.
 *   [4] In 'keep' mode outserial is compared to, in other modes outserial is
 *       compared to only if outserial > arg_inbound_serial AND have_serial.
 */